{"ast":null,"code":"/*! flip - v1.1.2 - 2016-10-20\n* https://github.com/nnattawat/flip\n* Copyright (c) 2016 Nattawat Nonsung; Licensed MIT */\n(function ($) {\n  /*\n   * Private attributes and method\n   */\n  // Function from David Walsh: http://davidwalsh.name/css-animation-callback licensed with http://opensource.org/licenses/MIT\n  var whichTransitionEvent = function whichTransitionEvent() {\n    var t,\n        el = document.createElement(\"fakeelement\"),\n        transitions = {\n      \"transition\": \"transitionend\",\n      \"OTransition\": \"oTransitionEnd\",\n      \"MozTransition\": \"transitionend\",\n      \"WebkitTransition\": \"webkitTransitionEnd\"\n    };\n\n    for (t in transitions) {\n      if (el.style[t] !== undefined) {\n        return transitions[t];\n      }\n    }\n  };\n  /*\n   * Model declaration\n   */\n\n\n  var Flip = function Flip($el, options, callback) {\n    // Define default setting\n    this.setting = {\n      axis: \"y\",\n      reverse: false,\n      trigger: \"click\",\n      speed: 500,\n      forceHeight: false,\n      forceWidth: false,\n      autoSize: true,\n      front: '.front',\n      back: '.back'\n    };\n    this.setting = $.extend(this.setting, options);\n\n    if (typeof options.axis === 'string' && (options.axis.toLowerCase() === 'x' || options.axis.toLowerCase() === 'y')) {\n      this.setting.axis = options.axis.toLowerCase();\n    }\n\n    if (typeof options.reverse === \"boolean\") {\n      this.setting.reverse = options.reverse;\n    }\n\n    if (typeof options.trigger === 'string') {\n      this.setting.trigger = options.trigger.toLowerCase();\n    }\n\n    var speed = parseInt(options.speed);\n\n    if (!isNaN(speed)) {\n      this.setting.speed = speed;\n    }\n\n    if (typeof options.forceHeight === \"boolean\") {\n      this.setting.forceHeight = options.forceHeight;\n    }\n\n    if (typeof options.forceWidth === \"boolean\") {\n      this.setting.forceWidth = options.forceWidth;\n    }\n\n    if (typeof options.autoSize === \"boolean\") {\n      this.setting.autoSize = options.autoSize;\n    }\n\n    if (typeof options.front === 'string' || options.front instanceof $) {\n      this.setting.front = options.front;\n    }\n\n    if (typeof options.back === 'string' || options.back instanceof $) {\n      this.setting.back = options.back;\n    } // Other attributes\n\n\n    this.element = $el;\n    this.frontElement = this.getFrontElement();\n    this.backElement = this.getBackElement();\n    this.isFlipped = false;\n    this.init(callback);\n  };\n  /*\n   * Public methods\n   */\n\n\n  $.extend(Flip.prototype, {\n    flipDone: function flipDone(callback) {\n      var self = this; // Providing a nicely wrapped up callback because transform is essentially async\n\n      self.element.one(whichTransitionEvent(), function () {\n        self.element.trigger('flip:done');\n\n        if (typeof callback === 'function') {\n          callback.call(self.element);\n        }\n      });\n    },\n    flip: function flip(callback) {\n      if (this.isFlipped) {\n        return;\n      }\n\n      this.isFlipped = true;\n      var rotateAxis = \"rotate\" + this.setting.axis;\n      this.frontElement.css({\n        transform: rotateAxis + (this.setting.reverse ? \"(-180deg)\" : \"(180deg)\"),\n        \"z-index\": \"0\"\n      });\n      this.backElement.css({\n        transform: rotateAxis + \"(0deg)\",\n        \"z-index\": \"1\"\n      });\n      this.flipDone(callback);\n    },\n    unflip: function unflip(callback) {\n      if (!this.isFlipped) {\n        return;\n      }\n\n      this.isFlipped = false;\n      var rotateAxis = \"rotate\" + this.setting.axis;\n      this.frontElement.css({\n        transform: rotateAxis + \"(0deg)\",\n        \"z-index\": \"1\"\n      });\n      this.backElement.css({\n        transform: rotateAxis + (this.setting.reverse ? \"(180deg)\" : \"(-180deg)\"),\n        \"z-index\": \"0\"\n      });\n      this.flipDone(callback);\n    },\n    getFrontElement: function getFrontElement() {\n      if (this.setting.front instanceof $) {\n        return this.setting.front;\n      } else {\n        return this.element.find(this.setting.front);\n      }\n    },\n    getBackElement: function getBackElement() {\n      if (this.setting.back instanceof $) {\n        return this.setting.back;\n      } else {\n        return this.element.find(this.setting.back);\n      }\n    },\n    init: function init(callback) {\n      var self = this;\n      var faces = self.frontElement.add(self.backElement);\n      var rotateAxis = \"rotate\" + self.setting.axis;\n      var perspective = self.element[\"outer\" + (rotateAxis === \"rotatex\" ? \"Height\" : \"Width\")]() * 2;\n      var elementCss = {\n        'perspective': perspective,\n        'position': 'relative'\n      };\n      var backElementCss = {\n        \"transform\": rotateAxis + \"(\" + (self.setting.reverse ? \"180deg\" : \"-180deg\") + \")\",\n        \"z-index\": \"0\",\n        \"position\": \"relative\"\n      };\n      var faceElementCss = {\n        \"backface-visibility\": \"hidden\",\n        \"transform-style\": \"preserve-3d\",\n        \"position\": \"absolute\",\n        \"z-index\": \"1\"\n      };\n\n      if (self.setting.forceHeight) {\n        faces.outerHeight(self.element.height());\n      } else if (self.setting.autoSize) {\n        faceElementCss.height = '100%';\n      }\n\n      if (self.setting.forceWidth) {\n        faces.outerWidth(self.element.width());\n      } else if (self.setting.autoSize) {\n        faceElementCss.width = '100%';\n      } // Back face always visible on Chrome #39\n\n\n      if ((window.chrome || window.Intl && Intl.v8BreakIterator) && 'CSS' in window) {\n        //Blink Engine, add preserve-3d to self.element\n        elementCss[\"-webkit-transform-style\"] = \"preserve-3d\";\n      }\n\n      faces.css(faceElementCss).find('*').css({\n        \"backface-visibility\": \"hidden\"\n      });\n      self.element.css(elementCss);\n      self.backElement.css(backElementCss); // #39\n      // not forcing width/height may cause an initial flip to show up on\n      // page load when we apply the style to reverse the backface...\n      // To prevent self we first apply the basic styles and then give the\n      // browser a moment to apply them. Only afterwards do we add the transition.\n\n      setTimeout(function () {\n        // By now the browser should have applied the styles, so the transition\n        // will only affect subsequent flips.\n        var speedInSec = self.setting.speed / 1000 || 0.5;\n        faces.css({\n          \"transition\": \"all \" + speedInSec + \"s ease-out\"\n        }); // This allows flip to be called for setup with only a callback (default settings)\n\n        if (typeof callback === 'function') {\n          callback.call(self.element);\n        } // While this used to work with a setTimeout of zero, at some point that became\n        // unstable and the initial flip returned. The reason for this is unknown but we\n        // will temporarily use a short delay of 20 to mitigate this issue.\n\n      }, 20);\n      self.attachEvents();\n    },\n    clickHandler: function clickHandler(event) {\n      if (!event) {\n        event = window.event;\n      }\n\n      if (this.element.find($(event.target).closest('button, a, input[type=\"submit\"]')).length) {\n        return;\n      }\n\n      if (this.isFlipped) {\n        this.unflip();\n      } else {\n        this.flip();\n      }\n    },\n    hoverHandler: function hoverHandler() {\n      var self = this;\n      self.element.off('mouseleave.flip');\n      self.flip();\n      setTimeout(function () {\n        self.element.on('mouseleave.flip', $.proxy(self.unflip, self));\n\n        if (!self.element.is(\":hover\")) {\n          self.unflip();\n        }\n      }, self.setting.speed + 150);\n    },\n    attachEvents: function attachEvents() {\n      var self = this;\n\n      if (self.setting.trigger === \"click\") {\n        self.element.on($.fn.tap ? \"tap.flip\" : \"click.flip\", $.proxy(self.clickHandler, self));\n      } else if (self.setting.trigger === \"hover\") {\n        self.element.on('mouseenter.flip', $.proxy(self.hoverHandler, self));\n        self.element.on('mouseleave.flip', $.proxy(self.unflip, self));\n      }\n    },\n    flipChanged: function flipChanged(callback) {\n      this.element.trigger('flip:change');\n\n      if (typeof callback === 'function') {\n        callback.call(this.element);\n      }\n    },\n    changeSettings: function changeSettings(options, callback) {\n      var self = this;\n      var changeNeeded = false;\n\n      if (options.axis !== undefined && self.setting.axis !== options.axis.toLowerCase()) {\n        self.setting.axis = options.axis.toLowerCase();\n        changeNeeded = true;\n      }\n\n      if (options.reverse !== undefined && self.setting.reverse !== options.reverse) {\n        self.setting.reverse = options.reverse;\n        changeNeeded = true;\n      }\n\n      if (changeNeeded) {\n        var faces = self.frontElement.add(self.backElement);\n        var savedTrans = faces.css([\"transition-property\", \"transition-timing-function\", \"transition-duration\", \"transition-delay\"]);\n        faces.css({\n          transition: \"none\"\n        }); // This sets up the first flip in the new direction automatically\n\n        var rotateAxis = \"rotate\" + self.setting.axis;\n\n        if (self.isFlipped) {\n          self.frontElement.css({\n            transform: rotateAxis + (self.setting.reverse ? \"(-180deg)\" : \"(180deg)\"),\n            \"z-index\": \"0\"\n          });\n        } else {\n          self.backElement.css({\n            transform: rotateAxis + (self.setting.reverse ? \"(180deg)\" : \"(-180deg)\"),\n            \"z-index\": \"0\"\n          });\n        } // Providing a nicely wrapped up callback because transform is essentially async\n\n\n        setTimeout(function () {\n          faces.css(savedTrans);\n          self.flipChanged(callback);\n        }, 0);\n      } else {\n        // If we didnt have to set the axis we can just call back.\n        self.flipChanged(callback);\n      }\n    }\n  });\n  /*\n   * jQuery collection methods\n   */\n\n  $.fn.flip = function (options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n    }\n\n    if (typeof options === \"string\" || typeof options === \"boolean\") {\n      this.each(function () {\n        var flip = $(this).data('flip-model');\n\n        if (options === \"toggle\") {\n          options = !flip.isFlipped;\n        }\n\n        if (options) {\n          flip.flip(callback);\n        } else {\n          flip.unflip(callback);\n        }\n      });\n    } else {\n      this.each(function () {\n        if ($(this).data('flip-model')) {\n          // The element has been initiated, all we have to do is change applicable settings\n          var flip = $(this).data('flip-model');\n\n          if (options && (options.axis !== undefined || options.reverse !== undefined)) {\n            flip.changeSettings(options, callback);\n          }\n        } else {\n          // Init\n          $(this).data('flip-model', new Flip($(this), options || {}, callback));\n        }\n      });\n    }\n\n    return this;\n  };\n})(jQuery);","map":null,"metadata":{},"sourceType":"script"}