{"ast":null,"code":"/*\n * glfx.js\n * http://evanw.github.com/glfx.js/\n *\n * Copyright 2011 Evan Wallace\n * Released under the MIT license\n */\nvar fx = function () {\n  function q(a, d, c) {\n    return Math.max(a, Math.min(d, c));\n  }\n\n  function w(b) {\n    return {\n      _: b,\n      loadContentsOf: function loadContentsOf(b) {\n        a = this._.gl;\n\n        this._.loadContentsOf(b);\n      },\n      destroy: function destroy() {\n        a = this._.gl;\n\n        this._.destroy();\n      }\n    };\n  }\n\n  function A(a) {\n    return w(r.fromElement(a));\n  }\n\n  function B(b, d) {\n    var c = a.UNSIGNED_BYTE;\n\n    if (a.getExtension(\"OES_texture_float\") && a.getExtension(\"OES_texture_float_linear\")) {\n      var e = new r(100, 100, a.RGBA, a.FLOAT);\n\n      try {\n        e.drawTo(function () {\n          c = a.FLOAT;\n        });\n      } catch (g) {}\n\n      e.destroy();\n    }\n\n    this._.texture && this._.texture.destroy();\n    this._.spareTexture && this._.spareTexture.destroy();\n    this.width = b;\n    this.height = d;\n    this._.texture = new r(b, d, a.RGBA, c);\n    this._.spareTexture = new r(b, d, a.RGBA, c);\n    this._.extraTexture = this._.extraTexture || new r(0, 0, a.RGBA, c);\n    this._.flippedShader = this._.flippedShader || new h(null, \"uniform sampler2D texture;varying vec2 texCoord;void main(){gl_FragColor=texture2D(texture,vec2(texCoord.x,1.0-texCoord.y));}\");\n    this._.isInitialized = !0;\n  }\n\n  function C(a, d, c) {\n    if (!this._.isInitialized || a._.width != this.width || a._.height != this.height) B.call(this, d ? d : a._.width, c ? c : a._.height);\n\n    a._.use();\n\n    this._.texture.drawTo(function () {\n      h.getDefaultShader().drawRect();\n    });\n\n    return this;\n  }\n\n  function D() {\n    this._.texture.use();\n\n    this._.flippedShader.drawRect();\n\n    return this;\n  }\n\n  function f(a, d, c, e) {\n    (c || this._.texture).use();\n\n    this._.spareTexture.drawTo(function () {\n      a.uniforms(d).drawRect();\n    });\n\n    this._.spareTexture.swapWith(e || this._.texture);\n  }\n\n  function E(a) {\n    a.parentNode.insertBefore(this, a);\n    a.parentNode.removeChild(a);\n    return this;\n  }\n\n  function F() {\n    var b = new r(this._.texture.width, this._.texture.height, a.RGBA, a.UNSIGNED_BYTE);\n\n    this._.texture.use();\n\n    b.drawTo(function () {\n      h.getDefaultShader().drawRect();\n    });\n    return w(b);\n  }\n\n  function G() {\n    var b = this._.texture.width,\n        d = this._.texture.height,\n        c = new Uint8Array(4 * b * d);\n\n    this._.texture.drawTo(function () {\n      a.readPixels(0, 0, b, d, a.RGBA, a.UNSIGNED_BYTE, c);\n    });\n\n    return c;\n  }\n\n  function k(b) {\n    return function () {\n      a = this._.gl;\n      return b.apply(this, arguments);\n    };\n  }\n\n  function x(a, d, c, e, g, n, l, p) {\n    var m = c - g,\n        h = e - n,\n        f = l - g,\n        k = p - n;\n    g = a - c + g - l;\n    n = d - e + n - p;\n    var q = m * k - f * h,\n        f = (g * k - f * n) / q,\n        m = (m * n - g * h) / q;\n    return [c - a + f * c, e - d + f * e, f, l - a + m * l, p - d + m * p, m, a, d, 1];\n  }\n\n  function y(a) {\n    var d = a[0],\n        c = a[1],\n        e = a[2],\n        g = a[3],\n        n = a[4],\n        l = a[5],\n        p = a[6],\n        m = a[7];\n    a = a[8];\n    var f = d * n * a - d * l * m - c * g * a + c * l * p + e * g * m - e * n * p;\n    return [(n * a - l * m) / f, (e * m - c * a) / f, (c * l - e * n) / f, (l * p - g * a) / f, (d * a - e * p) / f, (e * g - d * l) / f, (g * m - n * p) / f, (c * p - d * m) / f, (d * n - c * g) / f];\n  }\n\n  function z(a) {\n    var d = a.length;\n    this.xa = [];\n    this.ya = [];\n    this.u = [];\n    this.y2 = [];\n    a.sort(function (a, b) {\n      return a[0] - b[0];\n    });\n\n    for (var c = 0; c < d; c++) {\n      this.xa.push(a[c][0]), this.ya.push(a[c][1]);\n    }\n\n    this.u[0] = 0;\n    this.y2[0] = 0;\n\n    for (c = 1; c < d - 1; ++c) {\n      a = this.xa[c + 1] - this.xa[c - 1];\n      var e = (this.xa[c] - this.xa[c - 1]) / a,\n          g = e * this.y2[c - 1] + 2;\n      this.y2[c] = (e - 1) / g;\n      this.u[c] = (6 * ((this.ya[c + 1] - this.ya[c]) / (this.xa[c + 1] - this.xa[c]) - (this.ya[c] - this.ya[c - 1]) / (this.xa[c] - this.xa[c - 1])) / a - e * this.u[c - 1]) / g;\n    }\n\n    this.y2[d - 1] = 0;\n\n    for (c = d - 2; 0 <= c; --c) {\n      this.y2[c] = this.y2[c] * this.y2[c + 1] + this.u[c];\n    }\n  }\n\n  function u(a, d) {\n    return new h(null, a + \"uniform sampler2D texture;uniform vec2 texSize;varying vec2 texCoord;void main(){vec2 coord=texCoord*texSize;\" + d + \"gl_FragColor=texture2D(texture,coord/texSize);vec2 clampedCoord=clamp(coord,vec2(0.0),texSize);if(coord!=clampedCoord){gl_FragColor.a*=max(0.0,1.0-length(coord-clampedCoord));}}\");\n  }\n\n  function H(b) {\n    a.noise = a.noise || new h(null, \"uniform sampler2D texture;uniform float amount;varying vec2 texCoord;float rand(vec2 co){return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453);}void main(){vec4 color=texture2D(texture,texCoord);float diff=(rand(texCoord)-0.5)*amount;color.r+=diff;color.g+=diff;color.b+=diff;gl_FragColor=color;}\");\n    f.call(this, a.noise, {\n      amount: q(0, b, 1)\n    });\n    return this;\n  }\n\n  function I(b) {\n    a.vibrance = a.vibrance || new h(null, \"uniform sampler2D texture;uniform float amount;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);float average=(color.r+color.g+color.b)/3.0;float mx=max(color.r,max(color.g,color.b));float amt=(mx-average)*(-amount*3.0);color.rgb=mix(color.rgb,vec3(mx),amt);gl_FragColor=color;}\");\n    f.call(this, a.vibrance, {\n      amount: q(-1, b, 1)\n    });\n    return this;\n  }\n\n  function J(b, d) {\n    a.vignette = a.vignette || new h(null, \"uniform sampler2D texture;uniform float size;uniform float amount;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);float dist=distance(texCoord,vec2(0.5,0.5));color.rgb*=smoothstep(0.8,size*0.799,dist*(amount+size));gl_FragColor=color;}\");\n    f.call(this, a.vignette, {\n      size: q(0, b, 1),\n      amount: q(0, d, 1)\n    });\n    return this;\n  }\n\n  function K(b) {\n    a.denoise = a.denoise || new h(null, \"uniform sampler2D texture;uniform float exponent;uniform float strength;uniform vec2 texSize;varying vec2 texCoord;void main(){vec4 center=texture2D(texture,texCoord);vec4 color=vec4(0.0);float total=0.0;for(float x=-4.0;x<=4.0;x+=1.0){for(float y=-4.0;y<=4.0;y+=1.0){vec4 sample=texture2D(texture,texCoord+vec2(x,y)/texSize);float weight=1.0-abs(dot(sample.rgb-center.rgb,vec3(0.25)));weight=pow(weight,exponent);color+=sample*weight;total+=weight;}}gl_FragColor=color/total;}\");\n\n    for (var d = 0; 2 > d; d++) {\n      f.call(this, a.denoise, {\n        exponent: Math.max(0, b),\n        texSize: [this.width, this.height]\n      });\n    }\n\n    return this;\n  }\n\n  function L(b, d) {\n    a.brightnessContrast = a.brightnessContrast || new h(null, \"uniform sampler2D texture;uniform float brightness;uniform float contrast;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);color.rgb+=brightness;if(contrast>0.0){color.rgb=(color.rgb-0.5)/(1.0-contrast)+0.5;}else{color.rgb=(color.rgb-0.5)*(1.0+contrast)+0.5;}gl_FragColor=color;}\");\n    f.call(this, a.brightnessContrast, {\n      brightness: q(-1, b, 1),\n      contrast: q(-1, d, 1)\n    });\n    return this;\n  }\n\n  function t(a) {\n    a = new z(a);\n\n    for (var d = [], c = 0; 256 > c; c++) {\n      d.push(q(0, Math.floor(256 * a.interpolate(c / 255)), 255));\n    }\n\n    return d;\n  }\n\n  function M(b, d, c) {\n    b = t(b);\n    1 == arguments.length ? d = c = b : (d = t(d), c = t(c));\n\n    for (var e = [], g = 0; 256 > g; g++) {\n      e.splice(e.length, 0, b[g], d[g], c[g], 255);\n    }\n\n    this._.extraTexture.initFromBytes(256, 1, e);\n\n    this._.extraTexture.use(1);\n\n    a.curves = a.curves || new h(null, \"uniform sampler2D texture;uniform sampler2D map;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);color.r=texture2D(map,vec2(color.r)).r;color.g=texture2D(map,vec2(color.g)).g;color.b=texture2D(map,vec2(color.b)).b;gl_FragColor=color;}\");\n    a.curves.textures({\n      map: 1\n    });\n    f.call(this, a.curves, {});\n    return this;\n  }\n\n  function N(b, d) {\n    a.unsharpMask = a.unsharpMask || new h(null, \"uniform sampler2D blurredTexture;uniform sampler2D originalTexture;uniform float strength;uniform float threshold;varying vec2 texCoord;void main(){vec4 blurred=texture2D(blurredTexture,texCoord);vec4 original=texture2D(originalTexture,texCoord);gl_FragColor=mix(blurred,original,1.0+strength);}\");\n\n    this._.extraTexture.ensureFormat(this._.texture);\n\n    this._.texture.use();\n\n    this._.extraTexture.drawTo(function () {\n      h.getDefaultShader().drawRect();\n    });\n\n    this._.extraTexture.use(1);\n\n    this.triangleBlur(b);\n    a.unsharpMask.textures({\n      originalTexture: 1\n    });\n    f.call(this, a.unsharpMask, {\n      strength: d\n    });\n\n    this._.extraTexture.unuse(1);\n\n    return this;\n  }\n\n  function O(b) {\n    a.sepia = a.sepia || new h(null, \"uniform sampler2D texture;uniform float amount;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);float r=color.r;float g=color.g;float b=color.b;color.r=min(1.0,(r*(1.0-(0.607*amount)))+(g*(0.769*amount))+(b*(0.189*amount)));color.g=min(1.0,(r*0.349*amount)+(g*(1.0-(0.314*amount)))+(b*0.168*amount));color.b=min(1.0,(r*0.272*amount)+(g*0.534*amount)+(b*(1.0-(0.869*amount))));gl_FragColor=color;}\");\n    f.call(this, a.sepia, {\n      amount: q(0, b, 1)\n    });\n    return this;\n  }\n\n  function P(b, d) {\n    a.hueSaturation = a.hueSaturation || new h(null, \"uniform sampler2D texture;uniform float hue;uniform float saturation;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);float angle=hue*3.14159265;float s=sin(angle),c=cos(angle);vec3 weights=(vec3(2.0*c,-sqrt(3.0)*s-c,sqrt(3.0)*s-c)+1.0)/3.0;float len=length(color.rgb);color.rgb=vec3(dot(color.rgb,weights.xyz),dot(color.rgb,weights.zxy),dot(color.rgb,weights.yzx));float average=(color.r+color.g+color.b)/3.0;if(saturation>0.0){color.rgb+=(average-color.rgb)*(1.0-1.0/(1.001-saturation));}else{color.rgb+=(average-color.rgb)*(-saturation);}gl_FragColor=color;}\");\n    f.call(this, a.hueSaturation, {\n      hue: q(-1, b, 1),\n      saturation: q(-1, d, 1)\n    });\n    return this;\n  }\n\n  function Q(b, d, c) {\n    a.zoomBlur = a.zoomBlur || new h(null, \"uniform sampler2D texture;uniform vec2 center;uniform float strength;uniform vec2 texSize;varying vec2 texCoord;\" + s + \"void main(){vec4 color=vec4(0.0);float total=0.0;vec2 toCenter=center-texCoord*texSize;float offset=random(vec3(12.9898,78.233,151.7182),0.0);for(float t=0.0;t<=40.0;t++){float percent=(t+offset)/40.0;float weight=4.0*(percent-percent*percent);vec4 sample=texture2D(texture,texCoord+toCenter*percent*strength/texSize);sample.rgb*=sample.a;color+=sample*weight;total+=weight;}gl_FragColor=color/total;gl_FragColor.rgb/=gl_FragColor.a+0.00001;}\");\n    f.call(this, a.zoomBlur, {\n      center: [b, d],\n      strength: c,\n      texSize: [this.width, this.height]\n    });\n    return this;\n  }\n\n  function R(b, d, c, e, g, n) {\n    a.tiltShift = a.tiltShift || new h(null, \"uniform sampler2D texture;uniform float blurRadius;uniform float gradientRadius;uniform vec2 start;uniform vec2 end;uniform vec2 delta;uniform vec2 texSize;varying vec2 texCoord;\" + s + \"void main(){vec4 color=vec4(0.0);float total=0.0;float offset=random(vec3(12.9898,78.233,151.7182),0.0);vec2 normal=normalize(vec2(start.y-end.y,end.x-start.x));float radius=smoothstep(0.0,1.0,abs(dot(texCoord*texSize-start,normal))/gradientRadius)*blurRadius;for(float t=-30.0;t<=30.0;t++){float percent=(t+offset-0.5)/30.0;float weight=1.0-abs(percent);vec4 sample=texture2D(texture,texCoord+delta/texSize*percent*radius);sample.rgb*=sample.a;color+=sample*weight;total+=weight;}gl_FragColor=color/total;gl_FragColor.rgb/=gl_FragColor.a+0.00001;}\");\n    var l = c - b,\n        p = e - d,\n        m = Math.sqrt(l * l + p * p);\n    f.call(this, a.tiltShift, {\n      blurRadius: g,\n      gradientRadius: n,\n      start: [b, d],\n      end: [c, e],\n      delta: [l / m, p / m],\n      texSize: [this.width, this.height]\n    });\n    f.call(this, a.tiltShift, {\n      blurRadius: g,\n      gradientRadius: n,\n      start: [b, d],\n      end: [c, e],\n      delta: [-p / m, l / m],\n      texSize: [this.width, this.height]\n    });\n    return this;\n  }\n\n  function S(b, d, c) {\n    a.lensBlurPrePass = a.lensBlurPrePass || new h(null, \"uniform sampler2D texture;uniform float power;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);color=pow(color,vec4(power));gl_FragColor=vec4(color);}\");\n    var e = \"uniform sampler2D texture0;uniform sampler2D texture1;uniform vec2 delta0;uniform vec2 delta1;uniform float power;varying vec2 texCoord;\" + s + \"vec4 sample(vec2 delta){float offset=random(vec3(delta,151.7182),0.0);vec4 color=vec4(0.0);float total=0.0;for(float t=0.0;t<=30.0;t++){float percent=(t+offset)/30.0;color+=texture2D(texture0,texCoord+delta*percent);total+=1.0;}return color/total;}\";\n    a.lensBlur0 = a.lensBlur0 || new h(null, e + \"void main(){gl_FragColor=sample(delta0);}\");\n    a.lensBlur1 = a.lensBlur1 || new h(null, e + \"void main(){gl_FragColor=(sample(delta0)+sample(delta1))*0.5;}\");\n    a.lensBlur2 = a.lensBlur2 || new h(null, e + \"void main(){vec4 color=(sample(delta0)+2.0*texture2D(texture1,texCoord))/3.0;gl_FragColor=pow(color,vec4(power));}\").textures({\n      texture1: 1\n    });\n\n    for (var e = [], g = 0; 3 > g; g++) {\n      var n = c + 2 * g * Math.PI / 3;\n      e.push([b * Math.sin(n) / this.width, b * Math.cos(n) / this.height]);\n    }\n\n    b = Math.pow(10, q(-1, d, 1));\n    f.call(this, a.lensBlurPrePass, {\n      power: b\n    });\n\n    this._.extraTexture.ensureFormat(this._.texture);\n\n    f.call(this, a.lensBlur0, {\n      delta0: e[0]\n    }, this._.texture, this._.extraTexture);\n    f.call(this, a.lensBlur1, {\n      delta0: e[1],\n      delta1: e[2]\n    }, this._.extraTexture, this._.extraTexture);\n    f.call(this, a.lensBlur0, {\n      delta0: e[1]\n    });\n\n    this._.extraTexture.use(1);\n\n    f.call(this, a.lensBlur2, {\n      power: 1 / b,\n      delta0: e[2]\n    });\n    return this;\n  }\n\n  function T(b) {\n    a.triangleBlur = a.triangleBlur || new h(null, \"uniform sampler2D texture;uniform vec2 delta;varying vec2 texCoord;\" + s + \"void main(){vec4 color=vec4(0.0);float total=0.0;float offset=random(vec3(12.9898,78.233,151.7182),0.0);for(float t=-30.0;t<=30.0;t++){float percent=(t+offset-0.5)/30.0;float weight=1.0-abs(percent);vec4 sample=texture2D(texture,texCoord+delta*percent);sample.rgb*=sample.a;color+=sample*weight;total+=weight;}gl_FragColor=color/total;gl_FragColor.rgb/=gl_FragColor.a+0.00001;}\");\n    f.call(this, a.triangleBlur, {\n      delta: [b / this.width, 0]\n    });\n    f.call(this, a.triangleBlur, {\n      delta: [0, b / this.height]\n    });\n    return this;\n  }\n\n  function U(b) {\n    a.edgeWork1 = a.edgeWork1 || new h(null, \"uniform sampler2D texture;uniform vec2 delta;varying vec2 texCoord;\" + s + \"void main(){vec2 color=vec2(0.0);vec2 total=vec2(0.0);float offset=random(vec3(12.9898,78.233,151.7182),0.0);for(float t=-30.0;t<=30.0;t++){float percent=(t+offset-0.5)/30.0;float weight=1.0-abs(percent);vec3 sample=texture2D(texture,texCoord+delta*percent).rgb;float average=(sample.r+sample.g+sample.b)/3.0;color.x+=average*weight;total.x+=weight;if(abs(t)<15.0){weight=weight*2.0-1.0;color.y+=average*weight;total.y+=weight;}}gl_FragColor=vec4(color/total,0.0,1.0);}\");\n    a.edgeWork2 = a.edgeWork2 || new h(null, \"uniform sampler2D texture;uniform vec2 delta;varying vec2 texCoord;\" + s + \"void main(){vec2 color=vec2(0.0);vec2 total=vec2(0.0);float offset=random(vec3(12.9898,78.233,151.7182),0.0);for(float t=-30.0;t<=30.0;t++){float percent=(t+offset-0.5)/30.0;float weight=1.0-abs(percent);vec2 sample=texture2D(texture,texCoord+delta*percent).xy;color.x+=sample.x*weight;total.x+=weight;if(abs(t)<15.0){weight=weight*2.0-1.0;color.y+=sample.y*weight;total.y+=weight;}}float c=clamp(10000.0*(color.y/total.y-color.x/total.x)+0.5,0.0,1.0);gl_FragColor=vec4(c,c,c,1.0);}\");\n    f.call(this, a.edgeWork1, {\n      delta: [b / this.width, 0]\n    });\n    f.call(this, a.edgeWork2, {\n      delta: [0, b / this.height]\n    });\n    return this;\n  }\n\n  function V(b, d, c) {\n    a.hexagonalPixelate = a.hexagonalPixelate || new h(null, \"uniform sampler2D texture;uniform vec2 center;uniform float scale;uniform vec2 texSize;varying vec2 texCoord;void main(){vec2 tex=(texCoord*texSize-center)/scale;tex.y/=0.866025404;tex.x-=tex.y*0.5;vec2 a;if(tex.x+tex.y-floor(tex.x)-floor(tex.y)<1.0)a=vec2(floor(tex.x),floor(tex.y));else a=vec2(ceil(tex.x),ceil(tex.y));vec2 b=vec2(ceil(tex.x),floor(tex.y));vec2 c=vec2(floor(tex.x),ceil(tex.y));vec3 TEX=vec3(tex.x,tex.y,1.0-tex.x-tex.y);vec3 A=vec3(a.x,a.y,1.0-a.x-a.y);vec3 B=vec3(b.x,b.y,1.0-b.x-b.y);vec3 C=vec3(c.x,c.y,1.0-c.x-c.y);float alen=length(TEX-A);float blen=length(TEX-B);float clen=length(TEX-C);vec2 choice;if(alen<blen){if(alen<clen)choice=a;else choice=c;}else{if(blen<clen)choice=b;else choice=c;}choice.x+=choice.y*0.5;choice.y*=0.866025404;choice*=scale/texSize;gl_FragColor=texture2D(texture,choice+center/texSize);}\");\n    f.call(this, a.hexagonalPixelate, {\n      center: [b, d],\n      scale: c,\n      texSize: [this.width, this.height]\n    });\n    return this;\n  }\n\n  function W(b, d, c, e) {\n    a.colorHalftone = a.colorHalftone || new h(null, \"uniform sampler2D texture;uniform vec2 center;uniform float angle;uniform float scale;uniform vec2 texSize;varying vec2 texCoord;float pattern(float angle){float s=sin(angle),c=cos(angle);vec2 tex=texCoord*texSize-center;vec2 point=vec2(c*tex.x-s*tex.y,s*tex.x+c*tex.y)*scale;return(sin(point.x)*sin(point.y))*4.0;}void main(){vec4 color=texture2D(texture,texCoord);vec3 cmy=1.0-color.rgb;float k=min(cmy.x,min(cmy.y,cmy.z));cmy=(cmy-k)/(1.0-k);cmy=clamp(cmy*10.0-3.0+vec3(pattern(angle+0.26179),pattern(angle+1.30899),pattern(angle)),0.0,1.0);k=clamp(k*10.0-5.0+pattern(angle+0.78539),0.0,1.0);gl_FragColor=vec4(1.0-cmy-k,color.a);}\");\n    f.call(this, a.colorHalftone, {\n      center: [b, d],\n      angle: c,\n      scale: Math.PI / e,\n      texSize: [this.width, this.height]\n    });\n    return this;\n  }\n\n  function X(b) {\n    a.ink = a.ink || new h(null, \"uniform sampler2D texture;uniform float strength;uniform vec2 texSize;varying vec2 texCoord;void main(){vec2 dx=vec2(1.0/texSize.x,0.0);vec2 dy=vec2(0.0,1.0/texSize.y);vec4 color=texture2D(texture,texCoord);float bigTotal=0.0;float smallTotal=0.0;vec3 bigAverage=vec3(0.0);vec3 smallAverage=vec3(0.0);for(float x=-2.0;x<=2.0;x+=1.0){for(float y=-2.0;y<=2.0;y+=1.0){vec3 sample=texture2D(texture,texCoord+dx*x+dy*y).rgb;bigAverage+=sample;bigTotal+=1.0;if(abs(x)+abs(y)<2.0){smallAverage+=sample;smallTotal+=1.0;}}}vec3 edge=max(vec3(0.0),bigAverage/bigTotal-smallAverage/smallTotal);gl_FragColor=vec4(color.rgb-dot(edge,edge)*strength*100000.0,color.a);}\");\n    f.call(this, a.ink, {\n      strength: b * b * b * b * b,\n      texSize: [this.width, this.height]\n    });\n    return this;\n  }\n\n  function Y(b, d, c, e) {\n    a.dotScreen = a.dotScreen || new h(null, \"uniform sampler2D texture;uniform vec2 center;uniform float angle;uniform float scale;uniform vec2 texSize;varying vec2 texCoord;float pattern(){float s=sin(angle),c=cos(angle);vec2 tex=texCoord*texSize-center;vec2 point=vec2(c*tex.x-s*tex.y,s*tex.x+c*tex.y)*scale;return(sin(point.x)*sin(point.y))*4.0;}void main(){vec4 color=texture2D(texture,texCoord);float average=(color.r+color.g+color.b)/3.0;gl_FragColor=vec4(vec3(average*10.0-5.0+pattern()),color.a);}\");\n    f.call(this, a.dotScreen, {\n      center: [b, d],\n      angle: c,\n      scale: Math.PI / e,\n      texSize: [this.width, this.height]\n    });\n    return this;\n  }\n\n  function Z(b, d, c) {\n    a.matrixWarp = a.matrixWarp || u(\"uniform mat3 matrix;uniform bool useTextureSpace;\", \"if(useTextureSpace)coord=coord/texSize*2.0-1.0;vec3 warp=matrix*vec3(coord,1.0);coord=warp.xy/warp.z;if(useTextureSpace)coord=(coord*0.5+0.5)*texSize;\");\n    b = Array.prototype.concat.apply([], b);\n    if (4 == b.length) b = [b[0], b[1], 0, b[2], b[3], 0, 0, 0, 1];else if (9 != b.length) throw \"can only warp with 2x2 or 3x3 matrix\";\n    f.call(this, a.matrixWarp, {\n      matrix: d ? y(b) : b,\n      texSize: [this.width, this.height],\n      useTextureSpace: c | 0\n    });\n    return this;\n  }\n\n  function $(b, d, c, e) {\n    a.swirl = a.swirl || u(\"uniform float radius;uniform float angle;uniform vec2 center;\", \"coord-=center;float distance=length(coord);if(distance<radius){float percent=(radius-distance)/radius;float theta=percent*percent*angle;float s=sin(theta);float c=cos(theta);coord=vec2(coord.x*c-coord.y*s,coord.x*s+coord.y*c);}coord+=center;\");\n    f.call(this, a.swirl, {\n      radius: c,\n      center: [b, d],\n      angle: e,\n      texSize: [this.width, this.height]\n    });\n    return this;\n  }\n\n  function aa(b, d, c, e) {\n    a.bulgePinch = a.bulgePinch || u(\"uniform float radius;uniform float strength;uniform vec2 center;\", \"coord-=center;float distance=length(coord);if(distance<radius){float percent=distance/radius;if(strength>0.0){coord*=mix(1.0,smoothstep(0.0,radius/distance,percent),strength*0.75);}else{coord*=mix(1.0,pow(percent,1.0+strength*0.75)*radius/distance,1.0-percent);}}coord+=center;\");\n    f.call(this, a.bulgePinch, {\n      radius: c,\n      strength: q(-1, e, 1),\n      center: [b, d],\n      texSize: [this.width, this.height]\n    });\n    return this;\n  }\n\n  function ba(a, d) {\n    var c = x.apply(null, d),\n        e = x.apply(null, a),\n        c = y(c);\n    return this.matrixWarp([c[0] * e[0] + c[1] * e[3] + c[2] * e[6], c[0] * e[1] + c[1] * e[4] + c[2] * e[7], c[0] * e[2] + c[1] * e[5] + c[2] * e[8], c[3] * e[0] + c[4] * e[3] + c[5] * e[6], c[3] * e[1] + c[4] * e[4] + c[5] * e[7], c[3] * e[2] + c[4] * e[5] + c[5] * e[8], c[6] * e[0] + c[7] * e[3] + c[8] * e[6], c[6] * e[1] + c[7] * e[4] + c[8] * e[7], c[6] * e[2] + c[7] * e[5] + c[8] * e[8]]);\n  }\n\n  var v = {};\n\n  (function () {\n    function a(b) {\n      if (!b.getExtension(\"OES_texture_float\")) return !1;\n      var c = b.createFramebuffer(),\n          e = b.createTexture();\n      b.bindTexture(b.TEXTURE_2D, e);\n      b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);\n      b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);\n      b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);\n      b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);\n      b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, 1, 1, 0, b.RGBA, b.UNSIGNED_BYTE, null);\n      b.bindFramebuffer(b.FRAMEBUFFER, c);\n      b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, e, 0);\n      c = b.createTexture();\n      b.bindTexture(b.TEXTURE_2D, c);\n      b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR);\n      b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR);\n      b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);\n      b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);\n      b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, 2, 2, 0, b.RGBA, b.FLOAT, new Float32Array([2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));\n      var e = b.createProgram(),\n          d = b.createShader(b.VERTEX_SHADER),\n          g = b.createShader(b.FRAGMENT_SHADER);\n      b.shaderSource(d, \"attribute vec2 vertex;void main(){gl_Position=vec4(vertex,0.0,1.0);}\");\n      b.shaderSource(g, \"uniform sampler2D texture;void main(){gl_FragColor=texture2D(texture,vec2(0.5));}\");\n      b.compileShader(d);\n      b.compileShader(g);\n      b.attachShader(e, d);\n      b.attachShader(e, g);\n      b.linkProgram(e);\n      d = b.createBuffer();\n      b.bindBuffer(b.ARRAY_BUFFER, d);\n      b.bufferData(b.ARRAY_BUFFER, new Float32Array([0, 0]), b.STREAM_DRAW);\n      b.enableVertexAttribArray(0);\n      b.vertexAttribPointer(0, 2, b.FLOAT, !1, 0, 0);\n      d = new Uint8Array(4);\n      b.useProgram(e);\n      b.viewport(0, 0, 1, 1);\n      b.bindTexture(b.TEXTURE_2D, c);\n      b.drawArrays(b.POINTS, 0, 1);\n      b.readPixels(0, 0, 1, 1, b.RGBA, b.UNSIGNED_BYTE, d);\n      return 127 === d[0] || 128 === d[0];\n    }\n\n    function d() {}\n\n    function c(a) {\n      \"OES_texture_float_linear\" === a ? (void 0 === this.$OES_texture_float_linear$ && Object.defineProperty(this, \"$OES_texture_float_linear$\", {\n        enumerable: !1,\n        configurable: !1,\n        writable: !1,\n        value: new d()\n      }), a = this.$OES_texture_float_linear$) : a = l.call(this, a);\n      return a;\n    }\n\n    function e() {\n      var a = f.call(this);\n      -1 === a.indexOf(\"OES_texture_float_linear\") && a.push(\"OES_texture_float_linear\");\n      return a;\n    }\n\n    try {\n      var g = document.createElement(\"canvas\").getContext(\"experimental-webgl\");\n    } catch (n) {}\n\n    if (g && -1 === g.getSupportedExtensions().indexOf(\"OES_texture_float_linear\") && a(g)) {\n      var l = WebGLRenderingContext.prototype.getExtension,\n          f = WebGLRenderingContext.prototype.getSupportedExtensions;\n      WebGLRenderingContext.prototype.getExtension = c;\n      WebGLRenderingContext.prototype.getSupportedExtensions = e;\n    }\n  })();\n\n  var a;\n\n  v.canvas = function () {\n    var b = document.createElement(\"canvas\");\n\n    try {\n      a = b.getContext(\"experimental-webgl\", {\n        premultipliedAlpha: !1\n      });\n    } catch (d) {\n      a = null;\n    }\n\n    if (!a) throw \"This browser does not support WebGL\";\n    b._ = {\n      gl: a,\n      isInitialized: !1,\n      texture: null,\n      spareTexture: null,\n      flippedShader: null\n    };\n    b.texture = k(A);\n    b.draw = k(C);\n    b.update = k(D);\n    b.replace = k(E);\n    b.contents = k(F);\n    b.getPixelArray = k(G);\n    b.brightnessContrast = k(L);\n    b.hexagonalPixelate = k(V);\n    b.hueSaturation = k(P);\n    b.colorHalftone = k(W);\n    b.triangleBlur = k(T);\n    b.unsharpMask = k(N);\n    b.perspective = k(ba);\n    b.matrixWarp = k(Z);\n    b.bulgePinch = k(aa);\n    b.tiltShift = k(R);\n    b.dotScreen = k(Y);\n    b.edgeWork = k(U);\n    b.lensBlur = k(S);\n    b.zoomBlur = k(Q);\n    b.noise = k(H);\n    b.denoise = k(K);\n    b.curves = k(M);\n    b.swirl = k($);\n    b.ink = k(X);\n    b.vignette = k(J);\n    b.vibrance = k(I);\n    b.sepia = k(O);\n    return b;\n  };\n\n  v.splineInterpolate = t;\n\n  var r = function () {\n    function b(b, c, d, l) {\n      this.gl = a;\n      this.id = a.createTexture();\n      this.width = b;\n      this.height = c;\n      this.format = d;\n      this.type = l;\n      a.bindTexture(a.TEXTURE_2D, this.id);\n      a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR);\n      a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);\n      a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);\n      a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);\n      b && c && a.texImage2D(a.TEXTURE_2D, 0, this.format, b, c, 0, this.format, this.type, null);\n    }\n\n    function d(a) {\n      null == c && (c = document.createElement(\"canvas\"));\n      c.width = a.width;\n      c.height = a.height;\n      a = c.getContext(\"2d\");\n      a.clearRect(0, 0, c.width, c.height);\n      return a;\n    }\n\n    b.fromElement = function (c) {\n      var d = new b(0, 0, a.RGBA, a.UNSIGNED_BYTE);\n      d.loadContentsOf(c);\n      return d;\n    };\n\n    b.prototype.loadContentsOf = function (b) {\n      this.width = b.width || b.videoWidth;\n      this.height = b.height || b.videoHeight;\n      a.bindTexture(a.TEXTURE_2D, this.id);\n      a.texImage2D(a.TEXTURE_2D, 0, this.format, this.format, this.type, b);\n    };\n\n    b.prototype.initFromBytes = function (b, c, d) {\n      this.width = b;\n      this.height = c;\n      this.format = a.RGBA;\n      this.type = a.UNSIGNED_BYTE;\n      a.bindTexture(a.TEXTURE_2D, this.id);\n      a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, b, c, 0, a.RGBA, this.type, new Uint8Array(d));\n    };\n\n    b.prototype.destroy = function () {\n      a.deleteTexture(this.id);\n      this.id = null;\n    };\n\n    b.prototype.use = function (b) {\n      a.activeTexture(a.TEXTURE0 + (b || 0));\n      a.bindTexture(a.TEXTURE_2D, this.id);\n    };\n\n    b.prototype.unuse = function (b) {\n      a.activeTexture(a.TEXTURE0 + (b || 0));\n      a.bindTexture(a.TEXTURE_2D, null);\n    };\n\n    b.prototype.ensureFormat = function (b, c, d, l) {\n      if (1 == arguments.length) {\n        var f = arguments[0];\n        b = f.width;\n        c = f.height;\n        d = f.format;\n        l = f.type;\n      }\n\n      if (b != this.width || c != this.height || d != this.format || l != this.type) this.width = b, this.height = c, this.format = d, this.type = l, a.bindTexture(a.TEXTURE_2D, this.id), a.texImage2D(a.TEXTURE_2D, 0, this.format, b, c, 0, this.format, this.type, null);\n    };\n\n    b.prototype.drawTo = function (b) {\n      a.framebuffer = a.framebuffer || a.createFramebuffer();\n      a.bindFramebuffer(a.FRAMEBUFFER, a.framebuffer);\n      a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.id, 0);\n      if (a.checkFramebufferStatus(a.FRAMEBUFFER) !== a.FRAMEBUFFER_COMPLETE) throw Error(\"incomplete framebuffer\");\n      a.viewport(0, 0, this.width, this.height);\n      b();\n      a.bindFramebuffer(a.FRAMEBUFFER, null);\n    };\n\n    var c = null;\n\n    b.prototype.fillUsingCanvas = function (b) {\n      b(d(this));\n      this.format = a.RGBA;\n      this.type = a.UNSIGNED_BYTE;\n      a.bindTexture(a.TEXTURE_2D, this.id);\n      a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, c);\n      return this;\n    };\n\n    b.prototype.toImage = function (b) {\n      this.use();\n      h.getDefaultShader().drawRect();\n      var g = 4 * this.width * this.height,\n          f = new Uint8Array(g),\n          l = d(this),\n          p = l.createImageData(this.width, this.height);\n      a.readPixels(0, 0, this.width, this.height, a.RGBA, a.UNSIGNED_BYTE, f);\n\n      for (var m = 0; m < g; m++) {\n        p.data[m] = f[m];\n      }\n\n      l.putImageData(p, 0, 0);\n      b.src = c.toDataURL();\n    };\n\n    b.prototype.swapWith = function (a) {\n      var b;\n      b = a.id;\n      a.id = this.id;\n      this.id = b;\n      b = a.width;\n      a.width = this.width;\n      this.width = b;\n      b = a.height;\n      a.height = this.height;\n      this.height = b;\n      b = a.format;\n      a.format = this.format;\n      this.format = b;\n    };\n\n    return b;\n  }();\n\n  z.prototype.interpolate = function (a) {\n    for (var d = 0, c = this.ya.length - 1; 1 < c - d;) {\n      var e = c + d >> 1;\n      this.xa[e] > a ? c = e : d = e;\n    }\n\n    var e = this.xa[c] - this.xa[d],\n        g = (this.xa[c] - a) / e;\n    a = (a - this.xa[d]) / e;\n    return g * this.ya[d] + a * this.ya[c] + ((g * g * g - g) * this.y2[d] + (a * a * a - a) * this.y2[c]) * e * e / 6;\n  };\n\n  var h = function () {\n    function b(b, c) {\n      var d = a.createShader(b);\n      a.shaderSource(d, c);\n      a.compileShader(d);\n      if (!a.getShaderParameter(d, a.COMPILE_STATUS)) throw \"compile error: \" + a.getShaderInfoLog(d);\n      return d;\n    }\n\n    function d(d, f) {\n      this.texCoordAttribute = this.vertexAttribute = null;\n      this.program = a.createProgram();\n      d = d || c;\n      f = f || e;\n      f = \"precision highp float;\" + f;\n      a.attachShader(this.program, b(a.VERTEX_SHADER, d));\n      a.attachShader(this.program, b(a.FRAGMENT_SHADER, f));\n      a.linkProgram(this.program);\n      if (!a.getProgramParameter(this.program, a.LINK_STATUS)) throw \"link error: \" + a.getProgramInfoLog(this.program);\n    }\n\n    var c = \"attribute vec2 vertex;attribute vec2 _texCoord;varying vec2 texCoord;void main(){texCoord=_texCoord;gl_Position=vec4(vertex*2.0-1.0,0.0,1.0);}\",\n        e = \"uniform sampler2D texture;varying vec2 texCoord;void main(){gl_FragColor=texture2D(texture,texCoord);}\";\n\n    d.prototype.destroy = function () {\n      a.deleteProgram(this.program);\n      this.program = null;\n    };\n\n    d.prototype.uniforms = function (b) {\n      a.useProgram(this.program);\n\n      for (var c in b) {\n        if (b.hasOwnProperty(c)) {\n          var d = a.getUniformLocation(this.program, c);\n\n          if (null !== d) {\n            var e = b[c];\n            if (\"[object Array]\" == Object.prototype.toString.call(e)) switch (e.length) {\n              case 1:\n                a.uniform1fv(d, new Float32Array(e));\n                break;\n\n              case 2:\n                a.uniform2fv(d, new Float32Array(e));\n                break;\n\n              case 3:\n                a.uniform3fv(d, new Float32Array(e));\n                break;\n\n              case 4:\n                a.uniform4fv(d, new Float32Array(e));\n                break;\n\n              case 9:\n                a.uniformMatrix3fv(d, !1, new Float32Array(e));\n                break;\n\n              case 16:\n                a.uniformMatrix4fv(d, !1, new Float32Array(e));\n                break;\n\n              default:\n                throw \"dont't know how to load uniform \\\"\" + c + '\" of length ' + e.length;\n            } else if (\"[object Number]\" == Object.prototype.toString.call(e)) a.uniform1f(d, e);else throw 'attempted to set uniform \"' + c + '\" to invalid value ' + (e || \"undefined\").toString();\n          }\n        }\n      }\n\n      return this;\n    };\n\n    d.prototype.textures = function (b) {\n      a.useProgram(this.program);\n\n      for (var c in b) {\n        b.hasOwnProperty(c) && a.uniform1i(a.getUniformLocation(this.program, c), b[c]);\n      }\n\n      return this;\n    };\n\n    d.prototype.drawRect = function (b, c, d, e) {\n      var f = a.getParameter(a.VIEWPORT);\n      c = void 0 !== c ? (c - f[1]) / f[3] : 0;\n      b = void 0 !== b ? (b - f[0]) / f[2] : 0;\n      d = void 0 !== d ? (d - f[0]) / f[2] : 1;\n      e = void 0 !== e ? (e - f[1]) / f[3] : 1;\n      null == a.vertexBuffer && (a.vertexBuffer = a.createBuffer());\n      a.bindBuffer(a.ARRAY_BUFFER, a.vertexBuffer);\n      a.bufferData(a.ARRAY_BUFFER, new Float32Array([b, c, b, e, d, c, d, e]), a.STATIC_DRAW);\n      null == a.texCoordBuffer && (a.texCoordBuffer = a.createBuffer(), a.bindBuffer(a.ARRAY_BUFFER, a.texCoordBuffer), a.bufferData(a.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]), a.STATIC_DRAW));\n      null == this.vertexAttribute && (this.vertexAttribute = a.getAttribLocation(this.program, \"vertex\"), a.enableVertexAttribArray(this.vertexAttribute));\n      null == this.texCoordAttribute && (this.texCoordAttribute = a.getAttribLocation(this.program, \"_texCoord\"), a.enableVertexAttribArray(this.texCoordAttribute));\n      a.useProgram(this.program);\n      a.bindBuffer(a.ARRAY_BUFFER, a.vertexBuffer);\n      a.vertexAttribPointer(this.vertexAttribute, 2, a.FLOAT, !1, 0, 0);\n      a.bindBuffer(a.ARRAY_BUFFER, a.texCoordBuffer);\n      a.vertexAttribPointer(this.texCoordAttribute, 2, a.FLOAT, !1, 0, 0);\n      a.drawArrays(a.TRIANGLE_STRIP, 0, 4);\n    };\n\n    d.getDefaultShader = function () {\n      a.defaultShader = a.defaultShader || new d();\n      return a.defaultShader;\n    };\n\n    return d;\n  }(),\n      s = \"float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}\";\n\n  return v;\n}();\n\n\"object\" === typeof module ? module.exports = fx : window.fx = fx;","map":null,"metadata":{},"sourceType":"script"}